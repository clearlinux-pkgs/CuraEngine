Patch from Fedora package.

diff --git a/src/layerPart.cpp b/src/layerPart.cpp
index 80370fed..616c831d 100644
--- a/src/layerPart.cpp
+++ b/src/layerPart.cpp
@@ -49,7 +49,7 @@ void createLayerParts(SliceMeshStorage& mesh, Slicer* slicer)
 {
     const auto total_layers = slicer->layers.size();
     assert(mesh.layers.size() == total_layers);
-#pragma omp parallel for default(none) shared(mesh, slicer) schedule(dynamic)
+#pragma omp parallel for default(none) shared(mesh, slicer, total_layers) schedule(dynamic)
     for (unsigned int layer_nr = 0; layer_nr < total_layers; layer_nr++)
     {
         SliceLayer& layer_storage = mesh.layers[layer_nr];
diff --git a/src/support.cpp b/src/support.cpp
index dc39a8fe..13c69862 100644
--- a/src/support.cpp
+++ b/src/support.cpp
@@ -860,7 +860,7 @@ void AreaSupport::generateSupportAreasForMesh(SliceDataStorage& storage, const S
     constexpr bool no_prime_tower = false;
     xy_disallowed_per_layer[0] = storage.getLayerOutlines(0, no_support, no_prime_tower).offset(xy_distance);
     // for all other layers (of non support meshes) compute the overhang area and possibly use that when calculating the support disallowed area
-    #pragma omp parallel for default(none) shared(xy_disallowed_per_layer, storage, mesh) schedule(dynamic)
+    #pragma omp parallel for default(none) shared(xy_disallowed_per_layer, storage, mesh, layer_count, is_support_mesh_place_holder, use_xy_distance_overhang, z_distance_top, tan_angle, xy_distance, xy_distance_overhang) schedule(dynamic)
     for (size_t layer_idx = 1; layer_idx < layer_count; layer_idx++)
     {
         Polygons outlines = storage.getLayerOutlines(layer_idx, no_support, no_prime_tower);
@@ -1056,7 +1056,7 @@ void AreaSupport::generateSupportAreasForMesh(SliceDataStorage& storage, const S
         const int max_checking_layer_idx = std::min(static_cast<int>(storage.support.supportLayers.size())
                                                   , static_cast<int>(layer_count - (layer_z_distance_top - 1)));
         const size_t max_checking_idx_size_t = std::max(0, max_checking_layer_idx);
-#pragma omp parallel for default(none) shared(support_areas, storage) schedule(dynamic)
+#pragma omp parallel for default(none) shared(support_areas, storage, max_checking_idx_size_t, layer_z_distance_top) schedule(dynamic)
         for (size_t layer_idx = 0; layer_idx < max_checking_idx_size_t; layer_idx++)
         {
             constexpr bool no_support = false;
